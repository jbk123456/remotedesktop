'use strict';

var isInitiator;
var serverSocket = new WebSocket("ws://" + REMOTEDESKTOPHOST);
var selectors = [];
var socket = function () { };

serverSocket.onopen = function () {
  socket.emit('ipaddr');
}

socket.on = function (selector, f) {
  selectors[selector] = f;
}
socket.emit = function (msg) {
  serverSocket.send("GET /" + msg + "\r\n\r\n");
}
serverSocket.onmessage = function (e) {
  var idx = e.data.indexOf(" ");
  var k = e.data.substring(0, idx);
  var v = e.data.substring(idx + 1);
  selectors[k](v);
}

socket.on('joined', function (room, clientId) {
  console.log('This peer has joined room', room, 'with client ID', clientId);
  isInitiator = false;
  createPeerConnection(isInitiator, configuration);
});

socket.on('message', function (message) {
  message = JSON.parse(atob(message));
  console.log('Client received message:', message);
  signalingMessageCallback(message);
});


socket.on('disconnect', function (reason) {
  console.log(`Disconnected: ${reason}.`);
});

function sendMessage(tag, message) {
  console.log('Client sending message: ', tag, message);
  var c = "";
  for (var k in message) { c += (c.length ? "&" : "?") + k + "=" + btoa(message[k]) }
  socket.emit(tag + c);
  //  console.log('Client sent message: ', (tag+c));
}


function signalingMessageCallback(message) {
  if (message.type === 'offer') {
    console.log('Got offer. Sending answer to peer.');
    peerConn.setRemoteDescription(new RTCSessionDescription(message), function () { },
      logError);
    peerConn.createAnswer(onLocalSessionCreated, logError);

  } else if (message.type === 'answer') {
    console.log('Got answer.');
    peerConn.setRemoteDescription(new RTCSessionDescription(message), function () { },
      logError);

  } else if (message.type === 'candidate') {
    peerConn.addIceCandidate(new RTCIceCandidate({
      candidate: message.candidate,
      sdpMLineIndex: message.label,
      sdpMid: message.id
    }));

  }
}

function createPeerConnection(isInitiator, config) {
  console.log('Creating Peer connection as initiator?', isInitiator, 'config:',
    config);
  peerConn = new RTCPeerConnection(config);

  // send any ice candidates to the other peer
  peerConn.onicecandidate = function (event) {
    console.log('icecandidate event:', event);
    if (event.candidate) {
      sendMessage("ice", {
        type: 'candidate',
        label: event.candidate.sdpMLineIndex,
        id: event.candidate.sdpMid,
        candidate: event.candidate.candidate
      });
    } else {
      console.log('End of candidates.');
    }
  };

  if (isInitiator) {
    console.log('Creating Data Channel');
    dataChannel = peerConn.createDataChannel('dc');
    onDataChannelCreated(dataChannel);

    console.log('Creating an offer');
    peerConn.createOffer().then(function (offer) {
      return peerConn.setLocalDescription(offer);
    })
      .then(() => {
        console.log('sending local desc:', peerConn.localDescription);
        sendMessage("sdp", peerConn.localDescription);
      })
      .catch(logError);

  } else {
    peerConn.ondatachannel = function (event) {
      console.log('ondatachannel:', event.channel);
      dataChannel = event.channel;
      onDataChannelCreated(dataChannel);
    };
  }
}

function onLocalSessionCreated(desc) {
  console.log('local session created:', desc);
  peerConn.setLocalDescription(desc).then(function () {
    console.log('sending local desc:', peerConn.localDescription);
    sendMessage("sdp", peerConn.localDescription);
  }).catch(logError);
}

function onDataChannelCreated(channel) {
  console.log('onDataChannelCreated:', channel);

  channel.onopen = function () {
    console.log('CHANNEL opened!!!');
    sendBtn.disabled = false;
    snapAndSendBtn.disabled = false;
  };

  channel.onclose = function () {
    console.log('Channel closed.');
    sendBtn.disabled = true;
    snapAndSendBtn.disabled = true;
  }

  channel.onmessage = (adapter.browserDetails.browser === 'firefox') ?
    receiveDataFirefoxFactory() : receiveDataChromeFactory();
}

function receiveDataChromeFactory() {
  var buf, count;

  return function onmessage(event) {
    if (typeof event.data === 'string') {
      buf = window.buf = new Uint8ClampedArray(parseInt(event.data));
      count = 0;
      console.log('Expecting a total of ' + buf.byteLength + ' bytes');
      return;
    }

    var data = new Uint8ClampedArray(event.data);
    buf.set(data, count);

    count += data.byteLength;
    console.log('count: ' + count);

    if (count === buf.byteLength) {
      // we're done: all data chunks have been received
      console.log('Done. Rendering photo.');
      renderTile(buf);
    }
  };
}

function receiveDataFirefoxFactory() {
  var count, total, parts;

  return function onmessage(event) {
    if (typeof event.data === 'string') {
      total = parseInt(event.data);
      parts = [];
      count = 0;
      console.log('Expecting a total of ' + total + ' bytes');
      return;
    }

    parts.push(event.data);
    count += event.data.size;
    console.log('Got ' + event.data.size + ' byte(s), ' + (total - count) +
      ' to go.');

    if (count === total) {
      console.log('Assembling payload');
      var buf = new Uint8ClampedArray(total);
      var compose = function (i, pos) {
        var reader = new FileReader();
        reader.onload = function () {
          buf.set(new Uint8ClampedArray(this.result), pos);
          if (i + 1 === parts.length) {
            console.log('Done. Rendering photo.');
            renderTile(buf);
          } else {
            compose(i + 1, pos + this.result.byteLength);
          }
        };
        reader.readAsArrayBuffer(parts[i]);
      };
      compose(0, 0);
    }
  };
}
